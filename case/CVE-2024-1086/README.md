# user namespace 对该CVE的影响

## 关闭 user namespace 似乎能规避该CVE

[参考链接][nsfocus]

里面提到

> 2. If this module cannot be disabled, users can restrict user _ namespace 
> (user namespace) in Linux non-containerized deployment.
> ```
> RedHat/CentOS：
> # echo “user.max_user_namespaces=0” > /etc/sysctl.d/userns.conf
> # sysctl -p /etc/sysctl.d/userns.conf
> 
> Debian/Ubuntu：
> Temporarily disabled:
> # sudo sysctl -w kernel.unprivileged_userns_clone=0
> Permanently disabled:
> # echo kernel.unprivileged_userns_clone=0 | sudo tee /etc/sysctl.d/99-disable-unpriv-userns.conf
> ```

其方法是设置 `max_user_namespaces`为0 规避.


## 在4.18.0-372 centos 环境中测试
```
[root@localhost ~]# cat /proc/sys/user/max_user_namespaces
30803
[root@localhost ~]# echo 0 > /proc/sys/user/max_user_namespaces
[root@localhost ~]# cat /proc/sys/user/max_user_namespaces
0
[root@localhost ~]# su wang
[wang@localhost root]$ cd ~
[wang@localhost ~]$ ./exploit
[*] creating user namespace (CLONE_NEWUSER)...
unshare(CLONE_NEWUSER): No space left on device
```

报错代码为:
```cpp
static void do_unshare()
{
    int retv;

    printf("[*] creating user namespace (CLONE_NEWUSER)...\n");

        // do unshare seperately to make debugging easier
    retv = unshare(CLONE_NEWUSER);
        if (retv == -1) {
        perror("unshare(CLONE_NEWUSER)");
        exit(EXIT_FAILURE);
    }

    printf("[*] creating network namespace (CLONE_NEWNET)...\n");

    retv = unshare(CLONE_NEWNET);
    if (retv == -1)
        {
                perror("unshare(CLONE_NEWNET)");
                exit(EXIT_FAILURE);
        }
}
```

可以看到其先创建 USER 命名空间,然后再创建 NET 命名空间,在创建 USER 命名空间
就失败了.

## 查看产品中对user namespace 的使用

对CD 环境 PID 命名空间(这个肯定是用了)和user命名空间数量统计.
```
[root@node-5 1]# ps -o pidns  -ax  |grep -v PIDNS |sort |uniq |wc -l
224
[root@node-5 1]# ps -o userns -ax |grep -v USERNS |sort|uniq |wc -l
1
```

可以发现, user namespace 数量为1, 所以猜测产品中并未使用user namespace, 和
王博确认, 目前发布的产品中确实没有使用.

## 调研


[nsfocus]: https://nsfocusglobal.com/linux-kernel-privilege-escalation-vulnerability-cve-2024-1086-notice/
