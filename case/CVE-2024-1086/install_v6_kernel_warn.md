# 安装v6 kernel是 warn

## warn 打印信息
在安装v6 kernel 时， 会有一些WARN打印:
```
/usr/lib/dracut/modules.d/40network/module-setup.sh: line 31: warning: command substitution: ignored null byte in input
/usr/lib/dracut/modules.d/40network/module-setup.sh: line 33: warning: command substitution: ignored null byte in input
/usr/lib/dracut/modules.d/50drm/module-setup.sh: line 26: warning: command substitution: ignored null byte in input
/usr/lib/dracut/modules.d/50drm/module-setup.sh: line 28: warning: command substitution: ignored null byte in input
/usr/lib/dracut/modules.d/90kernel-modules/module-setup.sh: line 15: warning: command substitution: ignored null byte in input
/usr/lib/dracut/modules.d/90kernel-modules/module-setup.sh: line 17: warning: command substitution: ignored null byte in input
```

## 脚本分析

以90kernel-modules为例:
```bash
#!/bin/bash
block_module_filter() {
    local _blockfuncs='ahci_platform_get_resources|ata_scsi_ioctl|scsi_add_host|blk_cleanup_queue|register_mtd_blktrans|scsi_esp_register|register_virtio_device|usb_stor_disconnect|mmc_add_host|sdhci_add_host'
    # subfunctions inherit following FDs
    local _merge=8 _side2=9
    function bmf1() {
        local _f
        while read _f; do case "$_f" in
            *.ko)    [[ $(<         $_f) =~ $_blockfuncs ]] && echo "$_f" ;;    ### 还有这行
            *.ko.gz) [[ $(gzip -dc <$_f) =~ $_blockfuncs ]] && echo "$_f" ;;
            *.ko.xz) [[ $(xz -dc   <$_f) =~ $_blockfuncs ]] && echo "$_f" ;;    ### 这行
            esac
        done
        return 0
    }
    function rotor() {
        local _f1 _f2
        while read _f1; do
            echo $_f1
            if read _f2; then
                echo "$_f2" 1>&${_side2}
            fi
        done | bmf1 1>&${_merge}
        return 0
    }
    # Use two parallel streams to filter alternating modules.
    eval "( ( rotor ) ${_side2}>&1 | bmf1 ) ${_merge}>&1"
    [[ $debug ]] && set -x
    return 0
}

installkernel() {
    if [[ -z $drivers ]]; then
        ...
        find_kernel_modules  |  block_module_filter  |  instmods

    fi
}



```
该流程是向 initramfs中安装modules. `find_kernel_modules()` 是寻找 `/lib/modules/${KVER}`
下`modules.dep`文件中列举的module, 主要有两个分类
* intree: 只获取 drivers 路径下的module
* outtree: 都获取
  + updates/*
  + extra/*
  + weak-updates/*

```sh
find_kernel_modules_by_path () {
    local _OLDIFS

    [[ -f "$srcmods/modules.dep" ]] || return 0

    _OLDIFS=$IFS
    IFS=:
    while read a rest; do
        [[ $a = */$1/* ]] || [[ $a = updates/* ]] || [[ $a = extra/* ]] || [[ $a = weak-updates/* ]] ||continue
        printf "%s\n" "$srcmods/$a"
    done < "$srcmods/modules.dep"
    IFS=$_OLDIFS
    return 0
}

find_kernel_modules () {
    find_kernel_modules_by_path  drivers
}
```
而`installkernel()`中会将 `find_kernel_modules`输出，以管道再次输入到 `block_module_filter`, 
经过`block_module_filter`过滤， 在传入到 instmods中(instmods 负责向 dracut中安装module)。

```
find_kernel_modules  |  block_module_filter  |  instmods
```

而 `block_module_filter` 其目的是为了过滤出和block相关的modules
```sh
local _blockfuncs='ahci_platform_get_resources|ata_scsi_ioctl|....'
```

`block_module_filter` 会通过正则匹配module文件内容和 `_blockfuncs` 如果匹配成功，输出该文件路径。
而module文件可能是gzip格式或者xz格式. 需要用`gzip -dc` 和 `xz -dc`读取文件内容。

看起来这部分代码并没有问题。


## 测试该WARN是否造成非预期影响

我们首先来看下，这部分代码会不会造成非预期的影响。

我们以`ata_scsi_ioctl` 所在的module做下测试
```
[root@node-1 dracut]# cat /proc/kallsyms|grep ' ata_scsi_ioctl'
ffffffffc02a7c10 t ata_scsi_ioctl       [libata]
```

可以发现， 在`libata` modules中。


### 编写脚本测试

我们自己编写脚本测试下
```
echo /lib/modules/4.18.0-147.5.1.es7_28.x86_64/kernel/drivers/ata/libata.ko.xz  |block_module_filter
```
输出如下:
```
611_test.sh: line 11: warning: command substitution: ignored null byte in input
/lib/modules/4.18.0-147.5.1.es7_28.x86_64/kernel/drivers/ata/libata.ko.xz
```
第一行实际上是标准错误输出，不影响。我们可以重定向试试
```
[root@node-1 dracut-sh]# cat 611_test.sh |tail -1
echo /lib/modules/4.18.0-147.5.1.es7_28.x86_64/kernel/drivers/ata/libata.ko.xz  |block_module_filter 2>/dev/null
[root@node-1 dracut-sh]# sh 611_test.sh
/lib/modules/4.18.0-147.5.1.es7_28.x86_64/kernel/drivers/ata/libata.ko.xz
```
可以发现是符合预期的

### 解压initrd查找相关libata
解压后，我们查找下 libata, 并对比xfs, 查看libata是否存在并且位于正确的路径下。
```sh
[root@node-1 initrd]# find ./ -name 'libata.ko.xz'
./usr/lib/modules/4.18.0-147.5.1.es7_28.x86_64/kernel/drivers/ata/libata.ko.xz

[root@node-1 initrd]# find ./ -name 'xfs.ko.xz'
./usr/lib/modules/4.18.0-147.5.1.es7_28.x86_64/kernel/fs/xfs/xfs.ko.xz
```

可以发现符合预期。

## 问题原因调研

我们编写脚本测试

```sh
## FILE  test2.sh
list='aaa|bbb'

[[ $(< ./a.bin) =~ ${list} ]] && echo match
```
匹配当前路径下的`a.bin`文件内容， 是否能匹配 list, 如果能
输出match

* 向文件写入abaa
  ```sh
  [root@node-1 wangfuqiang]# echo abaa > a.bin
  [root@node-1 wangfuqiang]# xxd a.bin
  0000000: 6162 6161 0a                             abaa.
  [root@node-1 wangfuqiang]# sh test2.sh
  [root@node-1 wangfuqiang]#
  ```
  没有匹配到，不输出
* 向文件中写入aaa
  ```sh
  [root@node-1 wangfuqiang]# echo aaa > a.bin
  [root@node-1 wangfuqiang]# xxd a.bin
  0000000: 6161 610a                                aaa.
  [root@node-1 wangfuqiang]# sh test2.sh
  match
  ```
  匹配到，并且没有错误输出
* 向文件中写入`aaa\0'`
  ```sh
  [root@node-1 wangfuqiang]# echo -ne 'aaa\x0' > a.bin
  [root@node-1 wangfuqiang]# xxd a.bin
  0000000: 6161 6100                                aaa.
  [root@node-1 wangfuqiang]# sh test2.sh
  test2.sh: line 3: warning: command substitution: ignored null byte in input
  match
  ```
  虽然有warn, 但是能正常匹配

* 向文件中写入'\0aaa'
  ```sh
  [root@node-1 wangfuqiang]# echo -ne '\x00aaa' > a.bin
  [root@node-1 wangfuqiang]# xxd a.bin
  0000000: 0061 6161                                .aaa
  [root@node-1 wangfuqiang]# sh test2.sh
  test2.sh: line 3: warning: command substitution: ignored null byte in input
  match
  ```
  可以发现， 将'\0'前置， 也不影响后续字符的匹配。
* 向文件中写入`\x01aaa`
  ```
  [root@node-1 wangfuqiang]# echo -ne '\x01aaa' > a.bin
  [root@node-1 wangfuqiang]# xxd a.bin
  0000000: 0161 6161                                .aaa
  [root@node-1 wangfuqiang]# sh test2.sh
  match
  ```
  也可以匹配到，没有打印warn

* 向文件中写入'aa\0a' 
  ```
  [root@node-1 wangfuqiang]# xxd a.bin
  0000000: 6161 0061                                aa.a
  [root@node-1 wangfuqiang]# sh test2.sh
  test2.sh: line 3: warning: command substitution: ignored null byte in input
  match
  ```
  这个个人认为是bug. 理论上不应该匹配到, 我们测试下别的字符

* 向文件中写入'aa\x1a'
  ```sh
  [root@node-1 wangfuqiang]# echo -ne 'aa\x01a' > a.bin
  [root@node-1 wangfuqiang]# xxd a.bin
  0000000: 6161 0161                                aa.a
  [root@node-1 wangfuqiang]# sh test2.sh
  [root@node-1 wangfuqiang]#

  [root@node-1 wangfuqiang]# xxd a.bin
  0000000: 6161 0161 6262 62                        aa.abbb
  [root@node-1 wangfuqiang]# sh test2.sh
  match
  ```
  其他字符则不会匹配到。

# 结论
打印warn的原因是，module文件中含有'\0'字符。

如果有'\0'字符，会影响匹配但是个人认为影响很小，最起码不影响
initrd的正确性。原因如下。

以`ata_scsi_ioctl`函数为例。如果某个module A的elf文件中含
有`ata_scsi_\0ioctl` 这种数据， 其并不是说该文件中含有
`ata_scsi_ioctl`这样的符号，但是也会匹配到， 这样会将A 放入
到initrd中。并且据目前测试只会多匹配，也就是将不该匹配的匹配到，
这样会导致不该放到initrd的module放入，实际上不会造成太大影响。
