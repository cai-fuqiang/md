## 软件安装
* 安装`qemu-system`
  + dnf install qemu-system-loongarch64
* 安装`libvirtd`
  + `dnf install libvirt`
* 安装`edk2-ovmf-loongarch64`
  + dnf install edk2-ovmf-loongarch64


## 虚拟机启动

使用[xml](./wang.xml) 启动虚拟机，发现vnc链接不上。


## 调试

### qemu-monitor 查看寄存器
```
[root@localhost kvm]# virsh qemu-monitor-command wang --hmp 'info registers'

CPU#0
 PC=0000000000000000  FCSR0 0x00000000
 GPR00: r0 0000000000000000 r1 0000000000000000 r2 0000000000000000 r3 0000000000000000
 GPR04: r4 0000000000000000 r5 0000000000000000 r6 0000000000000000 r7 0000000000000000
 GPR08: r8 0000000000000000 r9 0000000000000000 r10 0000000000000000 r11 0000000000000000
 GPR12: r12 0000000000000000 r13 0000000000000000 r14 0000000000000000 r15 0000000000000000
 GPR16: r16 0000000000000000 r17 0000000000000000 r18 0000000000000000 r19 0000000000000000
 GPR20: r20 0000000000000000 r21 0000000000000000 r22 0000000000000000 r23 0000000000000000
 GPR24: r24 0000000000000000 r25 0000000000000000 r26 0000000000000000 r27 0000000000000000
 GPR28: r28 0000000000000000 r29 0000000000000000 r30 0000000000000000 r31 0000000000000000
CRMD=0000000000000008
PRMD=0000000000000000
EUEN=0000000000000000
ESTAT=00000000000d0000
ERA=0000000000000000
BADV=0000000000000000
BADI=0000000000000000
EENTRY=0000000000000000
PRCFG1=00000000000072f8, PRCFG2=000000003ffff000, PRCFG3=00000000008073f2
TLBRENTRY=0000000000000000
TLBRBADV=0000000000000000
TLBRERA=0000000000000000
TCFG=0000000000000000
TVAL=0000000000000000
 f0 0000000000000000 f1 0000000000000000 f2 0000000000000000 f3 0000000000000000
 f4 0000000000000000 f5 0000000000000000 f6 0000000000000000 f7 0000000000000000
 f8 0000000000000000 f9 0000000000000000 f10 0000000000000000 f11 0000000000000000
 f12 0000000000000000 f13 0000000000000000 f14 0000000000000000 f15 0000000000000000
 f16 0000000000000000 f17 0000000000000000 f18 0000000000000000 f19 0000000000000000
 f20 0000000000000000 f21 0000000000000000 f22 0000000000000000 f23 0000000000000000
 f24 0000000000000000 f25 0000000000000000 f26 0000000000000000 f27 0000000000000000
 f28 0000000000000000 f29 0000000000000000 f30 0000000000000000 f31 0000000000000000
```

发现寄存器并未初始化。

### 查看vcpu 堆栈
```sh
[root@localhost kvm]# ps -o comm,pid,tid,psr -p `pidof qemu-system-loongarch64` -T
COMMAND             PID     TID PSR
qemu-system-loo  130848  130848  66
qemu-system-loo  130848  130852  93
IO mon_iothread  130848  130853  91
CPU 0/KVM        130848  130854  64
vnc_worker       130848  130855  90

[root@localhost kvm]# cat /proc/130854/stack
[root@localhost kvm]#
```
并没有堆栈打印.

使用gdb 调试
```
Thread 4 (Thread 0x7fffef45a940 (LWP 130854) "CPU 0/KVM"):
#0  0x00007ffff15c6394 in ioctl () from target:/usr/lib64/libc.so.6
#1  0x0000555558f7e1c4 in kvm_vcpu_ioctl (cpu=cpu@entry=0x5555681443a0, type=type@entry=44672) at ../accel/kvm/kvm-all.c:3146
#2  0x0000555558f7e798 in kvm_cpu_exec (cpu=cpu@entry=0x5555681443a0) at ../accel/kvm/kvm-all.c:2958
#3  0x0000555558f80364 in kvm_vcpu_thread_fn (arg=arg@entry=0x5555681443a0) at ../accel/kvm/kvm-accel-ops.c:51
#4  0x000055555913acd0 in qemu_thread_start (args=<optimized out>) at ../util/qemu-thread-posix.c:541
#5  0x00007ffff1550d90 in ?? () from target:/usr/lib64/libc.so.6
#6  0x00007ffff15cb60c in ?? () from target:/usr/lib64/libc.so.6
```

发现vcpu 线程已经走到了`ioctl(VCPU_RUN, )`

### 打开 kvm trace

输出如下:
```
       CPU 0/KVM-130854  [065] d.... 158777.888630: kvm_reenter: vcpu 0 PC: 0x00000000
       CPU 0/KVM-130854  [065] ..... 158777.892627: kvm_exit: vcpu 0 [0x0] PC: 0x00000000
       CPU 0/KVM-130854  [065] d.... 158777.892629: kvm_reenter: vcpu 0 PC: 0x00000000
       CPU 0/KVM-130854  [065] ..... 158777.896628: kvm_exit: vcpu 0 [0x0] PC: 0x00000000
       CPU 0/KVM-130854  [065] d.... 158777.896629: kvm_reenter: vcpu 0 PC: 0x00000000
```
发现kvm一直在exit reenter,  并且PC一直是0

查看代码:
```sh
kvm_handle_exit
## 默认恢复虚拟机执行
=> ret = RESUME_GUEST
## 类似于 vmx exit basic reson
=> u32 ecode = (estat & CSR_ESTAT_EXC) >> CSR_ESTAT_EXC_SHIFT;

## 将ecode传入
##   kvm_exit: vcpu 0 [0x0] PC: 0x00000000
##                    ^^^^^
##                    ecode
=> trace_kvm_exit(vcpu, ecode);
## 有ecode处理下
=> if (ecode) {
        ret = kvm_handle_fault(vcpu, ecode);
   } else {
        WARN(!intr, "vm exiting with suspicious irq\n");
        ++vcpu->stat.int_exits;
   }
## 只有ecode != 0时，才能赋值非 RESUME_GUEST
=> if ret == RESUME_GUEST
   ## 进入guest前作准备
   => ret = kvm_pre_enter_guest(vcpu);

## 如果 kvm_handle_fault 返回其他值，或者 kvm_pre_enter_guest处理有问题。
## 则返回其他值
=> if ret != REUSME_GUEST
   => local_irq_disable();
   => return ret

=> return RESUME_GUEST;
```

**现在的问题是, ecode 一直返回0, 是在干啥**
