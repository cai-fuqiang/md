# 5 Interrupt Remapping and Interrupt Posting
This chapter discuss architecture and hardware details for 
interrupt-remapping and interrupt-posting.  
<br/>
<font color=gray face="黑体" size=2>
该章节讲述了interrupt-remapping 和 interrupt-posting的 architecture
和硬件细节。
</font>

## 5.1 Interrupt Remapping 
The interrupt-remapping architecture enables system software 
to control and censor external interrupt requests generated 
by all sources including those from interrupt controllers 
(I/OxAPICs), MSI/MSI-X capable devices including endpoints, 
root-ports and Root-Complex integrated end-points. 
<br/>
<font color=gray face="黑体" size=2>
interrupt-remapping architecture 让系统软件可以控制并审查由所有
中断源产生的外部中断请求, 这些中断源包括interrupt controllers(I/OxAPICs), 
MSI/MSI-X capable devices(包括 endpoints, root-ports和 Root-Complex 
integrated end-points)。
</font>

Interrupts generated by the remapping hardware itself (Fault 
Event and Invalidation Completion Events) are not subject to 
interrupt remapping. Interrupt requests appear to the Root-Complex 
as upstream memory write requests to the interrupt- address-range
0xFEEX_XXXXh. Since interrupt requests arrive at the 
Root-Complex as write requests, interrupt-remapping is co-located
with the remapping hardware units. The interrupt-remapping 
capability is reported through the Extended Capability Register.
<br/>
<font color=gray face="黑体" size=2>
出现在Root-Complex 上面的interrupt request 被当作 在 interruptaddress-range
0XFEEX_XXXXh 范围内的upstream。由于到达Root-Complex 上面的interrupt
requests 被当作 write request, interrupt-remapping 和 remapping hardware
units 位于同一位置上(co-located)。通过Extended Capablility Register
报告interrupt-remapping capability。
</font>

### 5.1.1 Identifying Origination of Interrupt Requests
To support domain-isolation usages, the platform hardware must
be capable of uniquely identifying the requestor (Source-Id) 
for each interrupt message. The interrupt sources in a 
platform and use of source-id in these requests may be 
categorized as follows:
<br/>
<font color=gray face="黑体" size=2>
为了支持 domain-isolation(域隔离)的用法, 硬件平台必须唯一标识
每个interrupt message 得到 requestor(Source-ID)。平台中的interrupt
source 和这些request 中的source-id的使用可能会如下分类:
</font>

* Message Signaled Interrupts from PCI-Express Devices
	+ For message-signaled interrupt requests from PCI-Express 
	devices, the source-id is the requester identifier in the 
	PCI-Express transaction header. The requester-id of a device
	is composed of its PCI Bus/Device/Function number assigned 
	by configuration software an uniquely identifies the hardware
	function that initiated the I/O request. Section 3.4.1 
	illustrates the requester-id as defined by the PCI-Express 
	specification. Section 3.9.4 describes use of source-id 
	field by PCI-Express devices using phantom functions.
	<br/>
	<font color=gray face="黑体" size=2>
	对于来自PCIE 设备的MSI request, source-id 是 requester 
	identifier并且在 PCI-E translation header 中。设备的requester-id
	由configuration software 分配的 PCI Bus/Device/Function number组成
	并且唯一标识I/O request的来自的hardware function。Section 3.4.1
	阐述了由PCI-E spec定义的requester-id。Section 3.9.4 描述了使用了
	phantom functions 的 PCI-E devices的source-id 字段的使用方法。
	</font>
* Message Signaled Interrupts from Root-Complex Integrated Devices
	+ For message-signaled interrupt requests from root-complex 
	integrated PCI or PCI-Express devices, the source-id is its 
	PCI requester-id.
	<br/>
	<font color=gray face="黑体" size=2>
	独有来自于root-complex integrated PCI/PCI-E device的MSI,source-id
	是他的PCI requester-id。
	</font>
* Message Signaled Interrupts from Devices behind PCI-Express
to PCI/PCI-X Bridges
	+ For message-signaled interrupt requests from devices behind
	PCI-Express-to-PCI/PCI-X bridges, the requester identifier 
	in those interrupt requests may be that of the interrupting 
	device or the requester-id with the bus number field equal 
	to the bridge’s secondary interface’s bus number and device 
	and function number fields value of zero. Section 3.9.1 
	describes legacy behavior of these bridges. Due to this aliasing,
	interrupt-remapping hardware does not isolate interrupts from
	individual devices behind such bridges.
	<br/>
	<font color=gray face="黑体" size=2>
	对于来自于PCI-E to PCI/PCI-X Bridges 后面的设备的MSI, 这些
	interrupt request中的requster identifier 可能是interrupting
	device的标识符或者是bus nunmber field和bridge's secondary
	interface的bus number相等并且device 和function number 字段
	为0的requester-id。Section 3.9.1 描述了这些bridge的传统的
	行为。因为这种别名，interrupt-remapping hardware 不能隔离
	来自于这些bridge后面的单独设备的中断。
	</font>
* Message Signaled Interrupts from Devices behind Conventional
 PCI bridges
	+ For message-signaled interrupt requests from devices behind
	conventional PCI bridges, the source-id in those interrupt 
	requests is the requestor-id of the legacy bridge device. 
	Section 3.9.2 describes legacy behavior of these bridges. 
	Due to this, interrupt-remapping hardware does not isolate 
	message-signaled interrupt requests from individual devices 
	behind such bridges.
	<br/>
	<font color=gray face="黑体" size=2>
	对于这些MSI, 这些interrupt requestes中的source-id是legacy
	bridge device 的 requestor-id。Section 3.9.2 描述了这些
	bridge的传统行为。由于上面描述的原因，interrupt-remapping 
	hardware 不能隔离来自于这些bridge后面的单独设备的中断。
	</font>
* Legacy pin interrupts
	+ For devices that use legacy methods for interrupt routing 
	(such as either through direct wiring to the I/OxAPIC input 
	pins, or through INTx messages), the I/OxAPIC hardware 
	generates the interrupt-request transaction. To identify the
	source of interrupt requests generated by I/OxAPICs, the 
	interrupt-remapping hardware requires each I/OxAPIC in the 
	platform (enumerated through the ACPI Multiple APIC Descriptor
	Tables (MADT)) to include a unique 16-bit source-id in its 
	requests. BIOS reports the source-id for these I/OxAPICs via
	ACPI structures to system software. Refer to Section 8.3.1.1
	for more details on I/OxAPIC identity reporting. 
	<br/>
	<font color=gray face="黑体" size=2>
	对于使用传统方法来路由interrupt的设备来说(例如通过直接些I/OxAPIC
	的input pins,或者通过INTx message), I/OxAPIC hardware 生成
	interrupt-request trnaslation。为了识别I/OxAPICs产生的interrupt
	requests的源, interrupt-remapping hardware 需要平台中的每个I/OxAPICs
	去包含在他们的requests中包含一个唯一的16-bit的source-id。BIOS
	通过ACPI structures 
	</font>
	
* Other Message Signaled Interrupts
	 * For any other platform devices that are not PCI discoverable
	 and yet capable of generating message-signaled interrupt 
	 requests (such as the integrated High Precision Event Timer -
	 HPET devices), the platform must assign unique source-ids 
	 that do not conflict with any other source-ids on the 
	 platform. BIOS must report the 16-bit source-id for these 
	 via ACPI structures described in Section 8.3.1.2.
	<br/>
	<font color=gray face="黑体" size=2>
	对于任何其他的平台设备来说，（这些平台设备不是PCI discoverable
	但是能够产生 MSI( 例如 integrated High Precision Event Timer - 
	HPET devices), 平台必须分配一个唯一的source-ids, 这个source-ids
	不能与平台上其他任何source-ids冲突。BIOS必须通过Section 8.3.1.2
	中描述的ACPI structures 报告一个16-bit source-id。
	</font>

### 5.1.2 Interrupt Request Formats On Intel® 64 Platforms
Interrupt-remapping on Intel(R) 64 platforms support two interrupt
request formats. These are described in the following sub-sections.
<br/>
<font color=gray face="黑体" size=2>
在Intel(R) 64p平台上的Interrput-remapping 支持两种interrupt request
formats。在下面的子章节中描述。
</font>

#### 5.1.2.1 Interrupt Requests in Compatibility Format
Figure 5-14 illustrates the interrupt request in Compatibility
format. The Interrupt Format field (Address bit 4) is Clear 
in Compatibility format requests. Refer to the Intel® 64 
Architecture software developer’s manuals for details on other
fields in the Compatibility format interrupt requests. Platforms
without interrupt-remapping capability support only Compatibility
format interrupts.
<br/>
<font color=gray face="黑体" size=2>
图5-14阐述了 Compatibility 格式的interrupt request。Interrupt Format
字段(Address bit 4) 在 Compatibility 中是clear状态。参考Intel sdm
了解关于Compatiblility 格式的interrupt request的其他字段的细节。
没有interrupt-remapping capability 的平台只支持 Compatibility
格式的interrupt。
</font>

![Figure-5-14](pic/Figure-5-14.png)

#### 5.1.2.2 Interrupt Requests in Remappable Format
Figure 5-15 illustrates the Remappable interrupt request 
format. The Interrupt Format field (Address bit 4) is Set for
Remappable format interrupt requests. Remappable interrupt 
requests are applicable only on platforms with interrupt-remapping
support.
<br/>
<font color=gray face="黑体" size=2>
Figure 5-15 阐述了 Remappable interrupt request format。对于Remappable
format interrupt requests, Interrupt Format field (Address bit 4) 被设
置。Remapping interrupt request 只适用于支持interrupt-remapping的平台。
</font>
![Figure-5-15](pic/Figure-5-15.png)

Table 6 describes the various address fields in the Remappable
interrupt request format.
<br/>
<font color=gray face="黑体" size=2>
Table 6描述了Remappable interrupt request format中的不同的地址字段
</font>

### 5.1.3 Interrupt Remapping Table
Interrupt-remapping hardware utilizes a memory-resident 
single-level table, called the Interrupt Remapping Table. 
The interrupt remapping table is expected to be setup by 
system software, and its base address and size is specified 
through the Interrupt Remap Table Address Register. Each entry
in the table is 128-bits in size and **is referred to as**
<sup>被称为</sup> Interrupt Remapping Table Entry (IRTE).Section 
9.10 illustrates the IRTE format.
<br/>
<font color=gray face="黑体" size=2>
Interrupt-remapping hardware 利用一个 memory-resident(驻留在内存的)
single-level table,称为Interrupt Remapping Table。该章节讲述了interrupt
remapping table 期望系统软件将其初始化，并且他的基地址和size通过
Interrupt Remapping Table Address Register 指定. 每个table中的entry
是128-bits大小并且被称为Interrupt Remapping Table Entry(IRTE)。
Section 9.10 阐述了IRTE 的格式.
</font>

For interrupt requests in Remappable format, the interrupt-remapping
hardware computes the ‘interrupt_index’ as below. The Handle, SHV
and Subhandle are respective fields from the interrupt address
and data per the Remappable interrupt format. 
<br/>
<font color=gray face="黑体" size=2>
对于Remapping format中的interrupt request, interrupt-remapping
hardware 通过下面计算`interrupt_index`, Handle, SHV和Subhandle来自于
每个Remapping interrupt 格式的interrupt address 和data相应字段
</font>
```
if (address.SHV == 0) {
	interrupt_index = address.handle;
} else {
	interrupt_index = (address.handle + data.subhandle);
}
```
The Interrupt Remap Table Address Register is programmed by 
software to specify the number of IRTEs in the Interrupt 
Remapping Table (maximum number of IRTEs in an Interrupt 
Remapping Table is 64K). Remapping hardware units in the 
platform may be configured to share interrupt-remapping table
or use independent tables. The interrupt_index is used to 
index the appropriate IRTE in the interrupt-remapping table. 
If the interrupt_index value computed is equal to or larger 
than the number of IRTEs in the remapping table, hardware 
treats the interrupt request as error.
<br/>
<font color=gray face="黑体" size=2>
Interrupt Remap Table Address Register被软件编程用来指定
Interrupt Remapping Table中的IRTEs的数量（一个Interrupt
Remapping Table中的IRTEs的最大数量为64K)。平台中的Remapping 
hardware units可能配置来共享interrupt-remapping table或者
使用独立的tables。interrupt_index用来索引interrupt-remapping
table中正确的IRTE。如果interrupt_index值计算大于或等于remapping
table中IRTEs的数量，hardware 将interrupt request当作error对待.
</font>

Unlike the Compatibility interrupt format where all the interrupt
attributes are encoded in the interrupt request address/data,
the Remappable interrupt format specifies only the fields needed
to compute the interrupt_index. The attributes of the remapped
interrupt request is specified through the IRTE referenced by
the interrupt_index.The interrupt-remapping architecture defines
support for hardware to cache frequently used IRTEs for improved
performance. For usages where software may need to dynamically
update the IRTE, architecture defines commands to invalidate
the IEC. Chapter 6 describes the caching constructs<sup>构图/建设/概念</sup> 
and associated invalidation commands. 
<br/>
<font color=gray face="黑体" size=2>
不像Compatibility interrupt format那样，所有interrupt attributes
都被编码到interrupt request address/data，Remapping Interrupt
format只指定了计算interrupt_index所需的字段。remapping interrupt
request 属性通过interrupt_index指向的IRTE指定。interrupt-remapping
architecture 定义了对于硬件缓存经常使用的IRTEs的支持，以用来提升性
能。对于软件可能需要动态更新IRTE的需求，architecture定义了去invalidate
IEC的cmd。Chapter 6  描述了缓存的架构和相关 invalidation commands。
</font>

### 5.1.4 Interrupt-Remapping Hardware Operation
The following provides a functional overview of the 
interrupt-remapping hardware operation:
<br/>
<font color=gray face="黑体" size=2>
下面提供了interrupt-remapping hardware 操作的功能概述:
</font>
* An interrupt request is identified by hardware as a DWORD 
sized write request to interrupt address ranges 0xFEEx_xxxx.
<br/>
<font color=gray face="黑体" size=2>
interrupt request被硬件识别为一个对intererupt address ranges
0xFEEx_xxxx 的DWORD size写请求。
</font>
* When interrupt-remapping is not enabled (IRES field Clear 
in Global Status Register), all interrupt requests are processed
per<sup>根据，按照</sup> the Compatibility interrupt request format described in 
Section 5.1.2.1.
<br/>
<font color=gray face="黑体" size=2>
当interrupt-remapping 没有enable(IRES 字段在Global Status Register
中clear),所有的interrupt request， 所有的interrupt request都按照
Section 5.1.2.1中描述的Compatibility interrupt request 格式处理。
</font>
* When interrupt-remapping is enabled (IRES field Set in Global
Status Register), interrupt requests are processed as follows:
<br/>
<font color=gray face="黑体" size=2>
当interrupt-remapping 是enabled( 设置了Global Status Register 中的IRES
字段), interupt request 会如下处理:
</font>
	+ Interrupt requests in the Compatibility format (i.e requests
	with Interrupt Format field Clear) are processed as follows:
	<br/>
	<font color=gray face="黑体" size=2>
	Compatibility 格式的interrupt request(也就是说 Interrupt Format
	字段清空的request) 被如下处理
	</font>
		* If Extended Interrupt Mode is enabled (EIME field in 
		Interrupt Remapping Table Address Register is Set), or if 
		the Compatibility format interrupts are disabled (CFIS 
		field in the Global Status Register is Clear), the 
		Compatibility format interrupts are blocked.
		<br/>
		<font color=gray face="黑体" size=2>
		如果Extended Interrupt Mode 是enabled(Interrupt Remapping
		Table Address Register 中的EIME字段被设置),或者是如果
		Compatibility format interrupts 是disabled (Global Status
		Register 是清空的), Compatibility format interrupt将
		被block。
		</font>
		* Else, Compatibility format interrupts are processed as
		pass-through (bypasses interrupt-remapping).
		<br/>
		<font color=gray face="黑体" size=2>
		Else,Compatibility format interrupts 将当作pass-through(bypasses
		interrupt-remapping)处理。
		</font>
	+ Interrupt requests in the Remappable format (i.e. request with
	Interrupt Format field Set) are processed as follows:
	<br/>
	<font color=gray face="黑体" size=2>
	Remappable format的Interrupt request （也就是说Interrupt Format
	field设置的request)将被如下处理:
	</font>
		* The reserved fields in the Remappable interrupt requests are
		checked to be zero. If the reserved field checking fails, 
		the interrupt request is blocked. Else, the Source-id, Handle,
		SHV, and Subhandle fields are retrieved from the interrupt 
		request.
		<br/>
		<font color=gray face="黑体" size=2>
		Remapping interrupt requests中的reserved字段将被检查为0.如果
		reserved 字段检查失败, interrupt request将被blocked。否则
		将从interrupt request中检索 Source-id, Handle, SHV和Subhandle
		字段。
		</font>
		* Hardware computes the interrupt_index per the algorithm 
		described in Section 5.1.3. The computed interrupt_index is
		validated to be less than the interrupt-remapping table size
		configured in the Interrupt Remap Table Address Register. If
		the bounds check fails, the interrupt request is blocked.
		<br/>
		<font color=gray face="黑体" size=2>
		hardware 通过Section 5.1.3中描述的算法计算interrupt_index。
		计算的interrupt_index将验证 是否小于Interrupt Remap Table Address
		Register 中配置的interrupt-remapping table size,如果边界检查
		失败，interrupt request将被block。
		</font>
		* If the above bounds check succeeds, the IRTE corresponding
		to the interrupt_index value is either retrieved from the 
		Interrupt Entry Cache, or fetched from the interrupt-remapping
		table. If the Coherent (C) field is reported as Clear in the
		Extended Capability Register, the IRTE fetch from memory will
		not snoop the processor caches. If the Present (P) field in the
		IRTE is Clear, the interrupt request is blocked and treated as
		fault.
		<br/>
		<font color=gray face="黑体" size=2>
		如果上面的边界检查成功了，interrupt_index对应的IRTE的值会
		从Interrupt Entry Cacahe中检索到，或者从interrupt-remapping table
		预取到。如果Coherent ( C ) 字段在 Extended Capablility Register
		中报告为clear，从memory中预取IRTE将不会snoop processor caches。
		如果IRTE中的Present(P) 字段被清空， interrupt request 将被阻塞
		并且将被当作fault对待.
		</font>
		* If IRTE is present (P=1), hardware performs verification 
		of the interrupt requester per the programming of the SVT, 
		SID and SQ fields in the IRTE as described in Section 9.10. 
		If the source-id checking fails, the interrupt request is 
		blocked.
		<br/>
		<font color=gray face="黑体" size=2>
		如果IRTE 是 present (P=1), hardware 通过编程在Section 9.10
		中描述的IRTE 中的SVT, SID,SQ字段执行对interrupt requester
		的验证。如果source-id 检查失败，interrupt request 将被blocked.
		</font>
	+ If IRTE has Mode field clear (IM=0):
		* Hardware interprets<sup>解释/翻译</sup> the IRTE in remappable format (as described
		in Section 9.10). If invalid programming of remappable-format IRTE 
		is detected, the interrupt request is blocked.
		<br/>
		<font color=gray face="黑体" size=2>
		硬件以remappable format解释 IRTE（在 Section 9.10中描述的那样)。如果检测到
		remapping-format IRTE中有非法编程，interrupt request将被阻塞。
		</font>
		* If above checks succeed, a remapped interrupt request is generated
		per the programming of the IRTE fields.
		<br/>
		<font color=gray face="黑体" size=2>
		如果上述检查成功，则根据IRTE中的编程的字段 remap interrupt request.
		</font>
* Any of the above checks that result in interrupt request to be blocked is 
treated as a interrupt-remapping fault condition. The interrupt-remapping fault 
conditions are enumerated in the following section.
<br/>
<font color=gray face="黑体" size=2>
导致interrupt request被 blocked 的上述的任何检查 将被当作 interrupt-remappping fault 
的情况对待。interrupt-remapping faults condition在接下来的的章节中列举。
</font>

#### 5.1.4.1 Interrupt Remapping Fault Conditions

### 5.1.5 Programming Interrupt Sources To Generate Remappable Interrupts

## 5.2 Interrupt Posting
Interrupt-posting capability is an extension of interrupt-remapping
hardware for extended processing of remappable format interrupt 
requests. Interrupt-posting enables a remappable format interrupt
request to be posted (recorded) in a coherent main memory resident
data-structure, with an optional notification event to the CPU
complex to signal pending posted interrupt. Interrupt-posting
capability (along with the support in Intel® 64 processors for
posted-interrupt processing and APIC Virtualization) enables a
Virtual Machine Monitor (VMM) software to efficiently process
interrupts from devices assigned to virtual machines. Section
2.5.3 describes high-level usages and benefits of interrupt-posting.
Refer to ‘Intel® 64 Architecture Software Developer's Manual, Volume 3B:
System Programming’ for details on Intel® 64 processor support
for APIC virtualization and posted-interrupt processing.
<br/>
<font color=gray face="黑体" size=2>
Interrupt-posting capability 为了扩展处理remappable format 
interrupt 的interrupt-remapping hardware 扩展。Interrupt-posting
enables remapping format interrupt request 能够 posted(recorded)
到 一致性的主存中驻留的 数据结构中，并且带有一个可选的 notification
event 到CPU complex，以发出挂起的posted interrupt。Interrupt-posting
capability(与Intel(R) 64 处理器对posted-interrupt processing 和APIC
Virtualization一起) 是的VMM software 可以有效的处理器来自于分配给
VM 设备的中断。Section 2.5.3 描述了高级的用法以及interrupt-posting
的有点。参考Intel sdm Volume 3B 了解更多Intel (R) 64处理器对APIC
virtualization 和 posted-interrupt processing 的支持。
</font>

Remapping hardware support for interrupt-posting capability is
reported through the Posted Interrupt Support (PI) field in the
Capability register (CAP_REG). Section 10.4.2 describes interrupt-posting
capability reporting.
<br/>
<font color=gray face="黑体" size=2>
对于interrupt-posting capability的 Remapping hardware 的支持通过
Capability register (CAP_REG)中的Posted Interrupt Support (PI) 字段
报告。Section 10.4.2 描述了 interrupt-posting capability reporting.
</font>

### 5.2.1 Interrupt Remapping Table Support for Interrupt Posting
All remappable interrupt requests are processed through the 
Interrupt Remapping Table as described in Section 5.1.3. The
IRTE Mode (IM) field in an Interrupt Remapping Table Entry 
(IRTE) specifies if remappable interrupt requests processed 
through that IRTE is subject to interrupt-remapping or 
interrupt-posting.
<br/>
<font color=gray face="黑体" size=2>
酥油的remappable interrupt requests 通过Section 5.1.3 描述的
Interrupt Remapping Table 处理。Interrupt Remapping Table Entry
(IRTE)中的IRTE Mode(IM) 字段 指定了remapping interrupt requests的
处理是否按照interrupt-remapping的IRTE,还是 interrupt-posting的IRTE。
</font>

* If the IM field is 0 in an IRTE, the IRTE is interpreted<sup>解释</sup> in
remappable format (described in Section 9.10) to remap interrupt
requests processed through it. The interrupt-remapping hardware
operation is described in Section 5.1.4.
<br/>
<font color=gray face="黑体" size=2>
如果IRTE中的IM字段为0, IRTE将解释为remappable format(Section 9.10中描述的)
去remap通过它处理器的interrupt request。 interrupt-remapping hardware
操作过程在Section 5.1.4中描述。
</font>
* If the IM field is 1 in an IRTE, the IRTE is interpreted in
posted format (described in Section 9.11) to post interrupt 
requests processed through it. The interrupt-posting hardware
operation is described in Section 5.2.3.
<br/>
<font color=gray face="黑体" size=2>
如果 IRTE中的IM字段为1, IRTE 被解释为posted format(在Section 9.11
中描述) 并通过它来post interrupt requests。interrupt-posting 
hardware 操作过程在Section 5.2.3 中描述.
</font>

IRTE entries in posted format support following new fields:
<br/>
<font color=gray face="黑体" size=2>
posted format 模式下的IRTE entries 支持下面的新字段:
</font>
* Address of the Posted Interrupt Descriptor data structure
to post (record) the interrupt to. Section 5.2.2 describes 
the Posted Interrupt Descriptor.
<br/>
<font color=gray face="黑体" size=2>
Posted Interrupt Descriptor data structure 的地址, 该structure
用于post (record) interrupt。Section 5.2.2 描述了Posted
Interrupt Descriptor.
</font>
* Urgent (URG) qualification to indicate if interrupt requests
processed through this IRTE require real-time processing or 
not. Section 5.2.3 describes the hardware operation with this
field.
<br/>
<font color=gray face="黑体" size=2>
Urgent (URG) qualification(紧急资格) 来指示通过该IRTE处理的interrupts
requests 是否需要实时处理。Section 5.2.3 描述了关于该字段的硬件
操作。
</font>
* Vector field specifies the vector to use when posting 
interrupts processed through an IRTE. Unlike remappable-format
(where the Vector field is used when generating the remapped
interrupt request), the Vector field for posted-format IRTEs
is used to determine which bit to Set when posting the interrupt
to the Posted Interrupt Descriptor referenced by the IRTE.
<br/>
<font color=gray face="黑体" size=2>
Vector field 只是posting interrupts 通过IRTE处理时 使用的vector。
不像remappable-format(该format Vector field 在生成remapped interrupt
request时使用), 对于posted-format IRTEs的Vector 字段被用做确定
当posting interrupt 到有IRTE引用的Posted Interrupt Descriptor 时，
那个位会被设置。
</font>

As with interrupt remapping, interrupts generated by the 
remapping hardware itself are not subject to interrupt 
posting.
<br/>
<font color=gray face="黑体" size=2>
和interrupt remapping 一样，remapping hardware 自身产生
的interrupt不受interrupt posting的影响。
</font>

### 5.2.2 Posted Interrupt Descriptor
Posted Interrupt Descriptor is a 64-byte aligned and sized 
structure in memory used by interrupt-posting hardware to post
(record) interrupt requests subject to posting. Section 9.12 
describes the Posted Interrupt Descriptor Format. System software
must allocate the Posted Interrupt Descriptors in coherent 
(write-back) main memory.
<br/>
<font color=gray face="黑体" size=2>
Posted Interrupt Descriptor 是一个以64-Byte对齐，并且大小也是64
byte的位于内存中的structure, 被interrupt-posting hardware用来
post(record) 要(subject to) posting 的interrupt requests,Section 9.12
描述了Posted Interrupt Descriptor Format。系统软件必须将Posted
Interrupt Descriptor 分配在 coherent(write-back) main memory.
</font>

The Posted Interrupt Descriptor hosts<sup>主办;做东;包含</sup> the following fields:
<br/>
<font color=gray face="黑体" size=2>
Posted Interrupt Descriptor 包含下面的字段:
</font>
* Posted Interrupt Request (PIR) field provides storage for 
posting (recording) interrupts (one bit per vector, **for up to**<sup>最多</sup>
256 vectors).
<br/>
<font color=gray face="黑体" size=2>
PIR字段： 提供了posting (recording) interrupt 的 存储 ( 每个bit
代表一个向量, 最多包含256个向量
</font>
* Outstanding Notification (ON) field indicates if there is 
a notification event outstanding<sup>未解决的</sup> (not processed by processor 
or software) for this Posted Interrupt Descriptor. When this 
field is 0, hardware modifies it from 0 to 1 when generating 
a notification event, and the entity<sup>实体</sup> receiving the notification
event (processor or software) resets it as part of posted 
interrupt processing.
<br/>
<font color=gray face="黑体" size=2>
ON 字段: 指示 对于该 Posted Interrupt Descriptor 是否有未解决的 
notification event( 没有被处理器或者软件处理)。当该字段为0, 
当生成一个 notification event时，hardware 将它从0修改为1，并且
接收 notification events的实体( processor/ software) 会重置它，
这也是处理posted interrupt 的流程之一。
</font>
* Suppress Notification (SN) field indicates if a notification
event is to be suppressed (not generated) for non-urgent interrupt
requests (interrupts processed through an IRTE with URG=0).
<br/>
<font color=gray face="黑体" size=2>
SN 字段: 指示 对于 non-urgent interrupt request(通过URG=0的IRTE
处理的中断) 的 notification event 是否会 suppressed(not generated)
(抑制)。
</font>
* Notification Vector (NV) field specifies the vector for 
notification event (interrupt).
<br/>
<font color=gray face="黑体" size=2>
NV字段:只是 notification event(interrupt)的 vector
</font>
* Notification Destination (NDST) field specifies the physical
APIC-ID of the destination logical processor for the notification
event.
<br/>
<font color=gray face="黑体" size=2>
NDST field: 指示  notification event的destination logical processor
的physical APIC-ID
</font>

### 5.2.3 Interrupt-Posting Hardware Operation
Interrupt requests in remappable format are processed by hardware
as described in Section 5.1.4. When such processing encounters
a IRTE entry in posted format (IM=1), the interrupt request is
processed through posting (instead of remapping). The following 
provides a functional overview of the interrupt-posting hardware
operation:
<br/>
<font color=gray face="黑体" size=2>
remappable 格式的 interrupt requests 通过硬件按照Section 5.1.4
章节中描述的那样去处理。当该余力过程遇到一个posted 格式(IM=1)
的IRTE时，interrupt request 将会按照posting 的方式处理.(而不是
remapping). 下面部分提供了interrupt-posting 硬件操作的功能性概述:
</font>
* If IRTE retrieved<sup>检索</sup> has Mode field as set (IM=1)1 
	<br/>
	<font color=gray face="黑体" size=2>
	如果IRTE检索到 Mode field 设置为1 :
	</font>
	+ Hardware interprets<sup>解释</sup> the IRTE in posted format (as described 
	in Section 9.11). If invalid programming of posted-format IRTE is 
	detected, the interrupt request is blocked.
	<br/>
	<font color=gray face="黑体" size=2>
	Hardware 将会按照posted format  的格式解释IRTE(在Section 9.11
	中描述的那样)。如果发现posted-format IRTE 被错误编程，则中断请求
	将会被blocked.
	</font>
	+ If above checks succeed, the IRTE provides the pointer to 
	the Posted Interrupt Descriptor (PDA-L/PDA-H), the vector 
	value (Vector) to be posted, and if the interrupt request 
	is qualified as urgent (URG) or not.
	<br/>
	<font color=gray face="黑体" size=2>
	如果上述的检查成功了，IRTE 提供指向Posted Interrupt Descriptor
	(PDA-L/PDA-H) 的指针，将要post 的vector value(Vector),和
	interrupt request是否有 urgent(URG)(紧急)的资格。
	</font>
* Hardware performs a coherent atomic read-modify-write 
operation of the posted-interrupt descriptor as follows:
	<br/>
	<font color=gray face="黑体" size=2>
	Hardware 对posted-interrupt descriptor 如下执行一个一致
	性的原子的 read-modify-write操作:
	</font>
	+ Read contents of the Posted Interrupt Descriptor, 
	claiming exclusive ownership of its hosting cache-line. If 
	invalid programming of Posted Interrupt Descriptor is detected,
	release ownership of the cache-line, and block the interrupt
	request.
	<br/>
	<font color=gray face="黑体" size=2>
	Read Posted Interrupt Descriptor 的内容，并声明拥有
	对于其所属的cache-line 有独家所有权。如果发现Posted Interrupt Descriptor
	有非法编程，释放该cache-line的所有权，并且阻塞interrupt request.
	</font>
	+ If above checks succeed, retrieve<sup>检索</sup> current values of Posted
	Interrupt Requests (PIR bits 255:0), Outstanding Notification
	(ON), Suppress Notification (SN), Notification Vector (NV),
	and Notification Destination (NDST) fields in the Posted 
	Interrupt Descriptor.
	<br/>
	<font color=gray face="黑体" size=2>
	如果上述检查成功，检索 Posted Interrupt Descriptor 中的Posted 
	Interrupt Requests 的当前值(PIR bit 255:0), Outstanding 
	Notification(NO), Suppress Notification(SN), Notification(NV),
	和 Notification Destination(NDST)字段
	</font>
	+ Modify the following descriptor field values atomically:
	<br/>
	<font color=gray face="黑体" size=2>
	原子的修改 descriptor中接下来的字段值:
	</font>
		* Set bit in PIR corresponding to the Vector field value 
		from the IRTE
		<br/>
		<font color=gray face="黑体" size=2>
		设置来自于IRTE 中的Vector 字段值所对应的 PIR bits.
		</font>
		* Compute X = ((ON == 0) & (URG | (SN == 0)))
		<br/>
		<font color=gray face="黑体" size=2>
		计算 X == ( (ON==0) & (URG | (SN == 0)) )<br/>
		也就是说:<br/>
		首先ON=0 <br/>
		URG == 1,  X=1<br/>
		URG == 0 并且 SN == 0,  X=1<br/>
		URG == 1表示是紧急的 Notification Event, SN=0 表示不
		suppressed 非紧急的 Notification Event.
		</font>
		* if (X == 1), Set ON field.
		<br/>
		<font color=gray face="黑体" size=2>
		如果 X==1, 设置 ON 字段
		</font>
	+ Promote<sup>推动</sup> the cache-line to be globally observable, so that 
	the modifications are visible to other caching agents. 
	Hardware may write-back the cache-line anytime after this 
	step.
	<br/>
	<font color=gray face="黑体" size=2>
	推动 cache-line 为 globally observable(全都能看见，这时是不
	是要进行cache同步?) , 因此该修改对于其他的caching agents
	是可见的。Hardware 可能会在此步骤之后的任何时间 write-back
	该cache-line
	</font>
	+ If (X == 1) in previous step, generate a notification event
	(interrupt) with attributes as follows:
	<br/>
	<font color=gray face="黑体" size=2>
	如果之前的步骤X==1, 会生成一个如下属性的 notification event
	(interrupt):
	</font>
		* NSDT field specifies the physical APIC-ID of destination
		 logical CPU. Refer to Section 9.12
		<br/>
		<font color=gray face="黑体" size=2>
		NSDT 字段指示了 destination logical CPU的 的physical APIC-ID.
		</font>
		* NV field specifies the vector to be used for the 
		notification interrupt to signal the destination CPU about 
		pending posted interrupt.
		<br/>
		<font color=gray face="黑体" size=2>
		NV 字段指示了用于 notification interrupt的vector, 该interrupt
		用于想destination CPU 发出有关 pending posted interrupt 的信号.
		</font>
		* Delivery mode field for notification interrupt is forced 
		to Fixed (000b) on how this field is interpreted for xAPIC 
		and x2APIC modes.
		<br/>
		<font color=gray face="黑体" size=2>
		on how: 在...方面
		<br/>
		Delivery mode 字段: 在xAPIC和x2APIC模式解释中， 
		notification interrupt 被强制为 Fixed(OOOb)
		</font>
		* Re-direction Hint field for notification interrupt is 
		forced to Clear (0b)
		<br/>
		<font color=gray face="黑体" size=2>
		对于Notification interrupt 来说 Re-direction Hint 字段 强制
		为clear(0b)
		</font>
		* Trigger Mode field for notification interrupt is forced to 
		Edge (0b)
		<br/>
		<font color=gray face="黑体" size=2>
		Tigger Mode: 强制为 Edge (0b)
		</font>
		* Trigger Mode Level field for notification interrupt is forced
		to Asserted (1b).
		<br/>
		<font color=gray face="黑体" size=2>
		Trigger Mode Level字: 强制为 Asserted (1b)
		</font>
* Any of the above checks that result in interrupt request to
be blocked is treated as a interrupt-remapping fault condition
as enumerated in Section 5.1.4.1.
<br/>
<font color=gray face="黑体" size=2>
上述的任何导致interrupt request 为blocked的检查将当作interrupt-remapping 
fault condition对待，在Section 5.1.4.1中列举。
</font>

### 5.2.4 Ordering Requirements for Interrupt Posting
This section summarizes the ordering requirements to **be met 
by**<sup>满足</sup> interrupt-posting hardware when posting interrupts.
<br/>
<font color=gray face="黑体" size=2>
该section 总结了在 posting interrupt时，interrupt-posting hardware
需要满足的排序要求。
</font>
* Interrupt requests are posted transactions and follow PCI-Express
posted ordering rules. This ensures that an interrupt request
will not be observed by software until all prior inbound posted
requests (writes) are committed to their destinations.
<br/>
<font color=gray face="黑体" size=2>
Interrupt requests 是posted transactions 并且按照 PCI-E posted
排序规则。这保证了所有之前的(prior) inbound posted requests(writes)
被提交到他们的 destinations之前，software 都不会发现这些中断
请求
</font>
	+ This requirement needs to be maintained even if the interrupt
	requests are posted. i.e., before an interrupt is posted 
	(recorded) in the posted-interrupt descriptor and made visible
	to software, all preceding posted requests must be completed.
	<br/>
	<font color=gray face="黑体" size=2>
	即使interrupt requests已经posted了，该需求仍然需要保持。
	也就是说，在一个中断被posted 在 post-interrupt descriptor
	并且对软件可见之前, 所有的之前的posted requests都需要被completed.
	</font>
* Since interrupt requests are posted transactions, upstream 
read completions must push preceding interrupt requests.
<br/>
<font color=gray face="黑体" size=2>
因为interrupt requests是posted transactions, 上游读 completion
需要在interrupt requests之前push.
</font>
	+ This requirement needs to be maintained even if one or more
	of the preceding interrupt requests are posted. i.e., An 
	upstream read completion must wait until all preceding 
	interrupts (irrespective of if they are remapped or posted) 
	are completed. In case of an interrupt that is posted, ‘completion’
	of the interrupt means, both the atomic update of the posted
	interrupt descriptor and the associated notification event are
	completed.
	<br/>
	<font color=gray face="黑体" size=2>
	即使一个或多个之前的interrupt request 已经posted了，该需求
	需要被保持。也就是说，在所有之前的interrupt(无论是remapped还是posted)
	完成之前，upstream read  completion 需要一直等待。在interrupt
	是posted的情况下, interrupt的completion意思是, 对posted interrupt
	descriptor的原子更新和相关的notification event都已经completed
	</font>
* In the interrupt-posting operation, hardware must make sure
that modifications to a posted-interrupt descriptor is 
observable to software before issuing the notification event
for that descriptor.
<br/>
<font color=gray face="黑体" size=2>
在interrupt-posting 操作中，硬件必须确保在提交对该 descriptor的 
notification event之前, 软件可以观察到对于posted-interrupt descriptor
的修改。
</font>

### 5.2.5 Using Interrupt Posting for Virtual Interrupt Delivery
This section is informative<sup>提供有用信息的;信息量大的</sup>
and intended to illustrate a  simplified example1 usage of how
a Virtual Machine Monitor (VMM) software may use interrupt-posting
hardware to support efficient delivery of virtual interrupts from
assigned devices to virtual machines.
<br/>
<font color=gray face="黑体" size=2>
该章节内容丰富，并旨在说明一个简单的示例用法, 该实例是VMM 软件
如何使用interrupt-posting hardware 来支持高效的 来自于分配给
VM的设备的 virtual interrupt.
</font>

VMM software may enable interrupt-posting for a virtual machine
as follows:
<br/>
<font color=gray face="黑体" size=2>
VMM software 可能 为 virtual machine 如下使能 interrupt-posting:
</font>
* For each virtual processor in the virtual machine, the VMM 
software may allocate a Posted Interrupt Descriptor. Each such
descriptor is used for posting all interrupts that are to be
delivered to the respective virtual processor.
<br/>
<font color=gray face="黑体" size=2>
对于VM中的每个虚拟处理器, VMM software可能为他们分配了各自的
Posted Interrupt Descriptor。每个 descriptor 被用于 posting
要delivered到相应的虚拟处理器上的所有interrupt。
</font>
* The VMM software allocates two physical interrupt vectors 
(across all logical CPUs in the platform) for notification 
events.
<br/>
<font color=gray face="黑体" size=2>
VMM software 分配了两个物理中断 vectors (跨平台中所有的逻辑CPUs)
用于notification events
</font>
	+ One of this physical vectors may be used as the ‘Active 
	Notification Vector’ (ANV) for posted interrupt notifications
	to any virtual processor that is active (executing) at the 
	time of posting an interrupt to it.
	<br/>
	<font color=gray face="黑体" size=2>
	其中一个 physical vectors 可能用于 'Active Notification Vector'
	(ANV) 用于 给任何在posting interrupt 时, 为active(executing) 状
	态的 virtual processor 提供 posted interrupt notification。
	</font>
	+ The other physical vector allocated may be used as the 
	‘Wake-up Notification Vector’ (WNV) for posted interrupt 
	notifications to any virtual processor that is blocked 
	(halted) at the time of posting an interrupt to it.
	<br/>
	<font color=gray face="黑体" size=2>
	另一个分配的 physical vector 可能用做 "Wake-up Notification
	Vector' (WNV) ，用于给任何 在posting interrupt时，处于blocked
	(halte)状态的 virtual processor 提供posted interrupt notification。
	</font>
* For each interrupt source from any assigned device(s) to 
this virtual machine, the VMM software may intercept<sup>捕获</sup> and 
virtualize the guest software programming of respective interrupt
resources (IOxAPIC entries and/or MSI/MSI-X registers). Through
this virtualization, the VMM software detects the target virtual
processor and virtual vector assigned by guest software.
<br/>
<font color=gray face="黑体" size=2>
对于来自任何分配给VM的devices的中断源，VMM sotware可以捕获并且
虚拟化 guest软件编程相应的interrupt resources的行为(IOxAPIC entries
和 MSI/MSI-X registers)。通过该虚拟化, VMM software可以检测到
由guest software分配的target virtual processor和 virtual vectors
</font>

* For each such interrupt source, the VMM software allocates 
a posted-format IRTE.
<br/>
<font color=gray face="黑体" size=2>
对于每个这样的中断源, VMM software 分配一个 posted-format IRTE.
</font>
	+ The vector field in each such IRTE is programmed by the VMM
	software with the respective virtual vector value assigned for
	the interrupt source by guest software.
	<br/>
	<font color=gray face="黑体" size=2>
	每个IRTE中的vector字段 被VMM software 编程为由guest software
	分配给中断源的相应的 virtual vector value。
	</font>
	+ The posted descriptor address field in each such IRTE is 
	programmed by the VMM software to reference the posted descriptor
	allocated for the virtual processor assigned by guest software
	for the interrupt source.
	<br/>
	<font color=gray face="黑体" size=2>
	每个IRTE中的 posted descriptor address 字段被VMM编程为posted descriptor
	的指针, 该posted descriptor 分配给 由guest software 分配的中断源的virtual 
	processor。
	</font>
	+ The urgent (URG) field in an IRTE is Set by the VMM software
	if the respective interrupt source is designated as requiring
	immediate (non-deferred) processing.
	<br/>
	<font color=gray face="黑体" size=2>
	IRTE 中的 urgent(URG)字段由VMM software设置，如果相应的中断源
	被指定为需要立刻(non-deferred)处理。
	</font>
* The VMM software configures the processor hardware to enable
APIC virtualization (including ‘virtual-interrupt delivery’ 
and ‘process posted interrupts’ capabilities) for the virtual
processors. 
<br/>
<font color=gray face="黑体" size=2>
VMM 软件配置processor hardware 为虚拟处理器来使能 APIC virtualization
(包括 `virtual-interrupt delivery`和`process posted interrupt` 
capabilitie。
</font>
	+ The ‘posted-interrupt notification vector’ for the virtual
	processors are configured with the ‘Active Notification Vector’
	(ANV) value described earlier in this section.
	<br/>
	<font color=gray face="黑体" size=2>
	对于提供给virtual processor 的`posted-interrupt notification vector`
	被配置为前面章节提到的`Active Notification Vector`(ANV)值
	</font>
	+ The ‘posted-interrupt descriptor’ for the virtual processors
	are configured with the address of the Posted Interrupt Descriptor
	allocated for respective virtual processors.
	<br/>
	<font color=gray face="黑体" size=2>
	对于提供给virtual processor 的 `posted-interrupt descriptor`被配置
	为 分配给相应virtual processors 的 Posted Interrupt Descriptor 
	的地址
	</font>

* The VMM software scheduler may manage a virtual processor’s
scheduling state as follows:
<br/>
<font color=gray face="黑体" size=2>
VMM software 调度器在管理virtual processor's 调度状态时可能需要如下
操作:
</font>
	+ When a virtual processor is selected for execution, the virtual
	processor state is designated<sup>指定为</sup> as ‘active’ before entering/resuming
	it. This state is specified in its Posted Interrupt Descriptor by
	programming its Notification Vector (NV) field with the ANV vector
	value. This allows all interrupts for this virtual processor that
	are received while it is active (running) are processed by the
	processor hardware without transferring control to the VMM software.
	The processor hardware processes these notification events (with ANV
	vector value) by transferring any posted interrupts in the Posted
	Interrupt Descriptor to the Virtual-APIC page of the virtual processor
	and directly delivering it (without VMM software intervention<sup>介入</sup>) to
	the virtual processor. Refer to ‘Intel® 64 Architecture Software
	Developer's Manual, Volume 3: System Programming Guide’ for details
	on Intel®64 processor support for APIC Virtualization and Posted-Interrupt
	Processing. 
	<br/>
	<font color=gray face="黑体" size=2>
	当一个virtual processor 被选择执行，virtual processor state 在进入/恢复
	之前被指定为`active`状态。该状态被指定在 Posted Interrupt Descriptor，
	通过编程他的Notification Vector(NV)字段为 ANV vector值。这样允许virtual 
	processor 在他是active(running)状态时，收到的所有interrupts在processor 
	hardware处理过程中不会将控制权转交给VMM software. processor hardware
	处理这些 notification events(带有 ANV vector value)会先将Posted
	Interrupt Descriptor中的任何posted interrupts传递到virtual processor
	中的Virtual-APIC page，然后直接 delivery 它（没有VMM software 的介入)
	到virtual processor。参考'Intel (R) sdm Volume 3) 了解更多Intel(R) 64
	处理器对APIC Virtualization 和 Posted-Interrupt Processing 的支持。
	</font>
	+ When a virtual processor is preempted (e.g., on quantum
	<sup>量子;额度</sup> expiry<sup>到期</sup>),
	the virtual processor state is designated as ‘ready-to-run’. This
	state is specified in its Posted Interrupt Descriptor by programming
	the Suppress Notification (SN) field to 1. This allows all non-urgent
	interrupts for this virtual processor received while it is in preempted
	state to be posted to its Posted Interrupts Descriptor without 
	generating a notification interrupt (thereby avoiding disruption<sup>扰乱;中断</sup>
	of currently running virtual processors). If there are interrupt
	sources qualified as urgent for targeting this virtual processor,
	the VMM software may also modify the NV field in the Posted Interrupt
	Descriptor to WNV vector value. This enables the VMM software to receive
	notifications (with WNV vector value) when urgent interrupts are
	posted when virtual processor is not running, allowing appropriate
	software actions (such as preempting the current running virtual
	processor and immediately scheduling this virtual processor). 
	<br/>
	<font color=gray face="黑体" size=2>
	当virtual processor 被抢占(例如, 额度到期（时间片走完)), virtual processor
	的状态被指定为"ready-to-run'。该状态在他的Posted Interrupt Descriptor被指定，
	通过编程 Suppress Notification (SN) 字段为1。他允许当virtual processor 处于
	preempted 状态时, 该virtual processor 接收的所有的non-urgent 中断都将
	被posted 到他的 Posted Interrupt Descriptor ,并且不会生成 notification
	interrupt(从而避免了打断当前running 的 virtual processor执行)。如果有
	一个中断源对于target 该virtual processor 具有urgent 资格，VMM software
	可能也需要修改Posted Interrupt Descriptor 中的NV field为 WNV vector value.
	当 virtual processor 不是active，posted urgent interrupt 时, 这样就使得 VMM 
	software 收到notification (带有WNV vector value)。并允许适当的software 行为 
	(例如 抢占当前整天在运行的 virtual processor ,并且立即调度给 该virtual 
	processor).
	</font>
	+ When a virtual processor halts (e.g., on execution of HLT 
	instruction), the VMM software may get control, blocks further
	execution of the virtual processor, and designate the virtual
	processor state as ‘halted’. This state is specified in its
	Posted Interrupt Descriptor by programming its Notification
	Vector (NV) field with the WNV vector value. This enables the
	VMM software to receive notifications (with WNV vector value)
	when any interrupt (urgent or non-urgent) is posted for this
	virtual processor, allowing appropriate software action (such
	as to schedule the virtual processor for future or immediate
	activation<sup>激活</sup>).
	<br/>
	<font color=gray face="黑体" size=2>
	当virtual processor halts时(例如,执行HLT指令), VMM software 可能
	会得到控制权，并blocks virtual processor 之后的执行，并且指定
	virtual processor的状态为`halted`. 该状态在他的Posted Interrupt
	Descriptor 中指定，通过编程 Notification Vector(NV)字段为WHV vector
	值。他使VMM software 可以接收notifications (带有WNV vector值的),
	当任意interrupt (urgent/non-urgent) 被posted到该virtual processor时，
	允许适当的软件行为(例如,之后将调度到virtual processor执行，或者
	立即激活该虚机)
	</font>
* When entering/resuming a virtual processor, the VMM software
may process any pending posted interrupts in its posted descriptor
as follows:
<br/>
<font color=gray face="黑体" size=2>
当 进入/恢复 一个virtual processor时，VMM software 可能需要如下处理在
posted descriptor 中的任意的pending posted interrupts。
</font>
	+ VMM first transitions<sup>过渡</sup> the virtual CPU to ‘active’ state 
	by programming the notification vector in the Posted 
	Interrupt Descriptor to ANV vector value.
	<br/>
	<font color=gray face="黑体" size=2>
	VMM 首先将 virtual CPU 过渡到 `active` 状态，通过编程Posted Interrupt
	Descriptor 中的 notification vector到 ANV vector 值。
	</font>
	+ VMM may check if there are pending interrupts in the posted
	descriptor (e.g. by scanning PIR field for non-zero value).
	<br/>
	<font color=gray face="黑体" size=2>
	VMM 可能会检查 posted descriptor 是否有pending interrupts 
	(例如: 通过扫描PIR字段中的非零值)
	</font>
	+ If there are pending posted interrupts, VMM may generate  
	a self-IPI1 (Inter Processor Interrupt to the same logical 
	CPU) with vector value of ANV, through the Local xAPIC. This
	interrupt is recognized by the processor as soon as interrupts
	are enabled in the virtual processor enter/resume path. Since
	the virtual processor is configured with ANV vector value as
	the ‘posted-interrupt notification vector’, this results in 
	processor hardware processing it same as any notification event
	it may receive while the virtual processor is active. This 
	approach enables the VMM software to ‘off-load’ the posted 
	interrupt processing (such as delivering the interrupt to the
	virtual processor through the Virtual-APIC) to the processor 
	hardware, irrespective of the scheduling state of the virtual
	processor when the interrupt was posted by remapping hardware
	to the Posted Interrupt Descriptor. 
	<br/>
	<font color=gray face="黑体" size=2>
	如果这里有pending posted interrupts, VMM可能通过Local xAPIC 会
	产生一个带有ANV vector value的self-IPI(发送给相同(自己) 逻辑CPU的 
	Inter Processor Interrupt)。一旦virtual processor 在进入/恢复的路
	径中使能 interrupts, 该interrupt就会被处理器识别。因此virtual processor
	会配置ANV vector作为 'posted-interrupt notification vector',这样
	将导致procoessor hardware 处理它，就想处理在virtual processor 处于
	active 状态下收到的任何notification event一样。这种方法使VMM software
	可以 'off-load'(卸载) processor hardware的 posted interrupt 处理(例如
	通过 Virtual-APIC delivering interrupt 到  virtual processor), 当interrupt
	已经通过remapping hardware posted到 Posted Interrupt Descriptor上时，
	不用管virtual processor 的调度状态。
	</font>
* The VMM software may also apply the ‘posted-interrupt processing’
capability of the processor to inject virtual interrupts generated
by VMM software to a virtual machine (in addition to interrupts 
from direct assigned devices to the virtual machine). This may be
done by the VMM software atomically ‘posting’ a virtual interrupt
to the Posted Interrupt Descriptor (using atomic/LOCK instructions
that enforces cache-line update atomicity) and generating a 
notification event (as IPI) to the logical processor identified
as notify destination in the Posted interrupt Descriptor.
<br/>
<font color=gray face="黑体" size=2>
VMM software 可能也使用 处理器的'posted-interrupt processing' 
capability来注入由VMM software 产生发送到virtual machine的 virtual
interrupt(除了来自于direct分配到virtual machine 设备的中断)。这
可能通过VMM software 原子的`posting`一个virtual interrupt 到
Posted Interrupt Descriptor(使用 atomic/LOCK 指令，这样的话强制cache-line
原子地更新)并且产生一个 notification event(IPI）给在 Posted interrupt
Descriptor中 notify destination 识别的逻辑处理器)。
</font>

* The VMM software may handle virtual processor migrations across
logical processors by atomically updating the Notification Destination
(NDST) field in the respective Posted Interrupt Descriptor to the
physical APIC-ID of the logical processor to which the virtual
processor is migrated to. This enables all new notification events
from the posted descriptor of this virtual processor to be routed
to the new logical processor. 
<br/>
<font color=gray face="黑体" size=2>
VMM software 可能会通过原子地将 相应的Posted Interrupt Descriptor中的
Notification Destination(NDST)字段更新为将要把virtual processor 迁移到
的逻辑处理器的物理APIC-ID来处理在logical processor 之间迁移virtual 
processor。他可以将来自于该virtual processor 的posted descriptor 上
的所有的新的 notification events 路由到 new logical processor.
</font>

### 5.2.6 Interrupt Posting for Level Triggered Interrupts
Level-triggered interrupts generated through IOxAPICs Redirection
Table Entries (illustrated in Figure 5-16) can be processed through
Interrupt Remap Table Entries (IRTE) for Posted Interrupts (illustrated
in Section 9.11). However, unlike with interrupt-remapping, all
interrupts (including level interrupts) processed by the posted
interrupt processing hardware are treated as edge-triggered interrupts.
Thus VMM software enabling posting of Level-triggered interrupts must
take special care to properly virtualize the End of Interrupt (EOI)
processing by the virtual processor. For example, the VMM software
may set up the virtual processor execution controls to gain control
on EOI operation to the Virtual APIC controller by guest software,
and virtualize the operation by performing a Directed- EOI to the
IOxAPIC that generated the level-triggered interrupt. A Directed-EOI
is performed by software writing directly to the IOxAPIC EOI register.
Refer to the IOxAPIC specification for details on IOxAPIC EOI register. 
<br/>
<font color=gray face="黑体" size=2>
通过IOxAPICs Redirection Table Entries(在图5-16说说明)生成的Level-
triggered interrupt可以通过用于Posted Interrupts(在Section 9.11中说明)
的Interrupt Remap Table Entries(IRTE) 处理。但是，不想interrupt-remapping,
所有的interrupts (包括level interrupts) 在被posted interrupt processing
hardware 处理时，被当作 edge-triggered interrupt处理. 虽然VMM software
在使能对Level-triggered interrupts时，必须对正确虚拟化 virtual processor
对EOI处理特别注意。例如, VMM software 可以设置 virtual processor execution
控制(对某些指令的trap?) 来获取guest software 对 Virtual APIC 控制器的EOI
操作，并且通过执行对IOxAPIC的Directed-EOI 来生成level-triggered interrupt
完成对EOI的虚拟化操作。Directed-EOI 通过software 直接对IOxAPIC EOI register
的写操作完成。参考 IOxAPIC spect了解更多关于IOxAPIC EOI register 的
更多细节。
</font> 
